<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>furikake</title>

<!--   <script>
    var canvas = document.getElementById("cvs");
    // var ctx = canvas.getContext("2d");
    var imgCnt = 25;  // 描画する画像の数
    var imgArray = [];  // 画像の情報を格納
    var cvsw = 800;   // canvasタグに指定したwidth
    var cvsh = 500;   // canvasタグに指定したheight
    // var imgBaseSizeW = 15;    // 画像の基本サイズ横幅
    // var imgBaseSizeH = 18.5;  // 画像の基本サイズ立幅

    // 今回は画像じゃなくてCSSでやる
      // 画像の読み込み
      // var img = new Image();
      // img.src = "./images/sakura.png";
      // img.onload = flow_start;

    ctx.beginPath();
    ctx.movaPath(10,10);
    ctx.lineTo(10,20);
    ctx.stroke();

  if (canvas.getContext) {
    var context = canvas.getContext('2d');
    //ここに具体的な描画内容を指定する
    //新しいパスを開始する
    context.beginPath();
    //パスの開始座標を指定する
    context.moveTo(100,20);
    //座標を指定してラインを引いていく
    context.lineTo(150,100);
    context.lineTo(50,100);
    //パスを閉じる（最後の座標から開始座標に向けてラインを引く）
    context.closePath();
    //現在のパスを輪郭表示する
    context.stroke();
  }

    function drawPetal(){
    }

    // 画像のパラメーターを設定
    function setImages(){
      for(var i = 0;i < imgCnt;i++){
        imgArray.push({
          "posx": Math.random()*cvsw,     // 初期表示位置x
          "posy": Math.random()*cvsh,     // 初期表示位置y
          // "sizew": imgBaseSizeW,          // 画像の横幅
          // "sizeh": imgBaseSizeH,          // 画像の縦幅
        });
      }
    }

    // 描画、パラメーターの更新
    var i = 0;
    function flow(){
      // ctx.clearRect(0,0,cvsw,cvsh);
      // for(i = 0;i < imgCnt;i++){
      //   imgArray[i].posy += 1;
      //   ctx.drawImage(img, imgArray[i].posx, imgArray[i].posy, imgArray[i].sizew , imgArray[i].sizeh);
      //   // 範囲外に描画された画像を上に戻す
      //   if(imgArray[i].posy >= cvsh){
      //     imgArray[i].posy = -imgArray[i].sizeh;
      //   }
      // }
    }

    function flow_start(){
      setImages();
      setInterval(flow,10);
    }
  </script> -->
<script type="text/javascript" src="./js/LZWEncoder.js"></script>
<script type="text/javascript" src="./js/NeuQuant.js"></script>
<script type="text/javascript" src="./js/GIFEncoder.js"></script>
<script type="text/javascript" src="./js/b64.js"></script>
<link rel="stylesheet" href="./bulma-0.8.0/css/bulma.min.css">
<link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
</head>
<body>
<section class="hero">
  <div class="hero-body">
    <div class="container">
      <h1 class="title">
        furikake
      </h1>
      <h2 class="subtitle">
        Seasoning for your illustrations
      </h2>
    </div>
  </div>
</section>
<section class="section">
  <div class="container">
    <div class="box content">
      <!-- お知らせゾーン -->
      <div class="notification is-primary">
        GIF生成に少し時間がかかります
      </div>
      <h2 class="title is-3">1.設定</h2>
      <div class="file">
        <label class="file-label">
          <input class="file-input" type="file" id="file" accept="image/png, image/jpeg">
          <span class="file-cta">
            <span class="file-icon">
              <i class="fas fa-upload"></i>
            </span>
            <span class="file-label">
              画像を選択
            </span>
          </span>
        </label>
      </div>
      <div class="control">
        <input type="range" min="1" max="5" list="tlist">
        <datalist id="tlist">
          <option value="2"></option>
          <option value="3"></option>
          <option value="4"></option>
        </datalist>
      </div>
      <div class="control">
        <label class="radio">
          <input type="radio" name="speed" checked>
          ふつう
        </label>
        <label class="radio">
          <input type="radio" name="speed">
          はやめ
        </label>
      </div>
      <button class="button">
        <span>この設定でふりかける</span>
      </button>
      <!-- 描画エリア -->
      <canvas id="canvas" width="800px" height="500px" style="display: none;"></canvas>

      <div class="buttons">
        <button class="button is-link is-fullwidth" onclick="convertToGif();">ダウンロード(GIF)</button>
        <a href="http://twitter.com/share?url=https://example.com&text=&hashtags=furikake" class="twitter-share-button button is-fullwidth">
          <span class="icon">
            <i class="fab fa-twitter"></i>
          </span>
          <span>Twitterに投稿</span>
        </a>
        <button class="button is-fullwidth">
          <span class="icon">
            <i class="fab fa-instagram"></i>
          </span>
          <span>Instagramに投稿</span>
        </button>
        <button class="button is-fullwidth">
          <span class="icon">
            <i class="fas fa-cogs"></i>
          </span>
          <span>設定を変えてみる</span>
        </button>
      </div>
    </div>
  <div>
</section>
<footer class="footer">
  <p>
    <strong>Footer</strong>
  </p>
</footer>

<script type="text/javascript">
  // canvas要素取得
  var canvas = document.getElementById('canvas');
  // CanvasRenderingContext2D取得
  var ctx = canvas.getContext('2d');
  // function drawHalfPetal(ctx, beginx, beginy) {
  //   // size変えるとradiusが合わなくなるっぽい（終点がずれる）
  //   var size = 30;
  //   var color = '#ffb7c5'

  //   ctx.moveTo(beginx, beginy);
  //   ctx.arcTo(beginx + size, beginy, beginx + size, beginy + size, 30);
  //   ctx.arcTo(beginx, beginx + size, beginx, beginy, 30);
  //   ctx.fillStyle = color;
  //   ctx.fill();
  // }

  // function drawPetal(ctx, beginx, beginy) {
  //   // レモン型を2枚ずらして重ねて先端が欠けた花びらの形を作る
  //   ctx.beginPath();
  //   drawHalfPetal(ctx, beginx, beginy);
  //   ctx.rotate(10 * Math.PI / 180);
  //   drawHalfPetal(ctx, beginx, beginy);
  // }

  // drawPetal(ctx, 0, 0);
  // drawPetal(ctx, 100, 100);
  // drawPetal(ctx, 300, 100); // 変になる(^p^)オヨヨ　くじけそう

  // ==============

  // 画像使うパターン（ほぼコピペ）
  var imgCnt = 20;          // 描画する画像の数
  var imgArray = [];          // 画像の情報を格納
  var cvsw = 800;           // canvasタグに指定したwidth
  var cvsh = 500;           // canvasタグに指定したheight
  var imgBaseSizeW = 15;    // 画像の基本サイズ横幅
  var imgBaseSizeH = 18.5;  // 画像の基本サイズ立幅
  var aspectMax = 1.5;      // アスペクト比計算時の最大値
  var aspectMin = 0.5;      // アスペクト比計算時の最小値
  var speedMax = 2.5;         // 落下速度の最大値
  var speedMin = 0.5;       // 落下速度の最小値
  var angleAdd = 4;         // 画像角度への加算値

  // 画像の読み込み
  var img = new Image();
  img.src = "./sakura01.png";
  // img.onload = flow_start;

  // 画像を同じキャンバスに書き出す
  document.getElementById("file").addEventListener("change", function (e) {
              canvas.style.display = 'block';
              var file = e.target.files;
              var reader = new FileReader();

              //ファイルが複数読み込まれた際に、1つめを選択
              reader.readAsDataURL(file[0]);

              //ファイルが読み込めたら
              reader.onload = function () {
                  // 繰り返してるので止める 変数のスコープ的にどうするのが一番いいのか・・・
                  if (typeof drawUpToCount !== 'undefined') clearTimeout(drawUpToCount);
                  var src = reader.result;
                  var img2 = new Image();
                  img2.src = src;
                  img2.onload = function () {
                      // キャンバスサイズをアップロードした画像に合わせる
                      // canvas.width = img2.width;
                      // canvas.height = img2.height;
                      ctx.drawImage(img2, 0, 0);
                  };

                  setImages();
                  // 画像変わったらちゃんと更新したいのでここで読んでる プレビュー出したい
                  encoder = new GIFEncoder();
                  encoder.setRepeat(0); //0  -> loop forever
                  encoder.setDelay(3); //go to next frame every n milliseconds
                  encoder.start();
                  var count = 0; // addFrameを永遠に繰り返しちゃうので回数決める

                  drawUpToCount = setInterval(function(){
                    ctx.globalAlpha = 1.0;
                    ctx.clearRect(0,0,cvsw,cvsh);
                    // ここで呼ばないと↑でclearしてるので画像も消えちゃう
                    ctx.drawImage(img2, 0,0)
                    ctx.globalAlpha = 0.4;
                    // 位置をずらしつつ設定した数まで増殖させるためのループ・・・だと思う
                    for(index = 0;index < imgCnt;index++){
                      imgArray[index].posy += imgArray[index].speedy;
                      imgArray[index].angle += Math.random()*angleAdd;
                      cos = Math.cos(imgArray[index].angle * rad);
                      sin = Math.sin(imgArray[index].angle * rad);
                      ctx.setTransform(cos, sin, sin, cos, imgArray[index].posx, imgArray[index].posy);
                      ctx.drawImage(img, 0, 0 , imgArray[index].sizew , imgArray[index].sizeh);
                      ctx.setTransform(1, 0, 0, 1, 0, 0);
                      // 範囲外に描画された画像を上に戻す
                      if(imgArray[index].posy >= cvsh){
                        imgArray[index].posy = -imgArray[index].sizeh;
                      }
                    }
                    // 必要数が揃った状態でフレームに収める GIFはコマを少し飛ばす
                    if (count < 200 && (count % 5 == 0)) {
                      console.log(count + '回目のloop')
                      encoder.addFrame(ctx)
                      count++;
                    } else if (count > 500) {
                      // canvasの描画は実行し続けるがキャプチャはここで終わり
                      encoder.finish();
                    } else {
                      count++;
                    }
                  },10);
                  // flow_start();
              };
          }, false);

  // 画像のパラメーターを設定
  function setImages(){
    var aspect = 0;
    for(var i = 0;i < imgCnt;i++){
      // 画像サイズに掛けるアスペクト比を0.5~1.5倍でランダムで生成
      aspect = Math.random()*(aspectMax-aspectMin)+aspectMin;
      imgArray.push({
        "posx": Math.random()*cvsw,   // 初期表示位置x
        "posy": Math.random()*cvsh,   // 初期表示位置y
        "sizew": imgBaseSizeW*aspect, // 画像の横幅
        "sizeh": imgBaseSizeH*aspect, // 画像の縦幅
        "speedy": Math.random()*(speedMax-speedMin)+speedMin,　// 画像が落ちていく速度
        "angle": Math.random()*360,   // 角度
      });
    }
  }

  // 描画、パラメーターの更新
  var index = 0;
  var cos = 0;
  var sin = 0;
  var rad = Math.PI / 180;
  function flow(){
    ctx.clearRect(0,0,cvsw,cvsh);
    ctx.drawImage(img2, 0,0)
    for(index = 0;index < imgCnt;index++){
      imgArray[index].posy += imgArray[index].speedy;
      imgArray[index].angle += Math.random()*angleAdd;
      cos = Math.cos(imgArray[index].angle * rad);
      sin = Math.sin(imgArray[index].angle * rad);
      ctx.setTransform(cos, sin, sin, cos, imgArray[index].posx, imgArray[index].posy);
      ctx.drawImage(img, 0, 0 , imgArray[index].sizew , imgArray[index].sizeh);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      // 範囲外に描画された画像を上に戻す
      if(imgArray[index].posy >= cvsh){
        imgArray[index].posy = -imgArray[index].sizeh;
      }
    }
  }

  // function flow_start(){
  //   setImages();
  //   setInterval(flow,10);
  // }

// canvas to GIF: https://github.com/antimatter15/jsgif
  function convertToGif() {

    // 画面表示ならこう
    // var binary_gif = encoder.stream().getData() //notice this is different from the as3gif package!
    // var data_url = 'data:image/gif;base64,'+encode64(binary_gif);

    // ダウンロード
    encoder.download("download.gif");
  }

</script>
</body>
<!-- ref: https://www.otwo.jp/blog/canvas_sakura/ -->
<style>
body {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

footer {
  margin-top: auto;
  background-color: #fff;
}
/** 一片の花びらを作る **/
.flake {
  /** 粘土的な（ピンクの正方形） **/
  position:absolute;
  height:0;
  width:0;
  border:10px solid pink;
  border-radius: 15px;
  border-top-right-radius:0;
  border-bottom-left-radius:0;
}

/** flakeを角度をつけて変えてる((レモン型)-(花びらの先端)ではなくレモン型2枚を角度ずらして重ねてる **/
.flake::after {
  content: "";
  display: block;
  position: absolute;
  top: -7px;
  left: -7px;
  height: 0;
  width: 0;
  border: 10px solid pink;
  border-radius: 15px;
  border-top-right-radius:0;
  border-bottom-left-radius:0;
  -webkit-transform: rotate(15deg);
  -ms-transform: rotate(15deg);
  transform: rotate(15deg);
}
</style>
</html>
